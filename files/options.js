//MagresView 
//by Simone Sturniolo
//
//Copyright 2013 Science and Technology Facilities Council
//This software is distributed under the terms of the GNU General Public License (GNU GPL)
//Please refer to the file COPYING for the text of the license

//Functions controlling the various possibilities present in the Options menu

//Molecule shift handling function; refer to periodicity.js for more details about the way periodic boundary conditions are applied

function shift_btn_handler()
{
	if (atom_set.lattice_pars.r == null)
	{
		alert("No lattice parameters detected in the file. Shifting is impossible");
		return;
	}
	
	//First: calculate shifts
	
	var a_par = atom_set.lattice_pars.r[0];
	var b_par = atom_set.lattice_pars.r[1];
	var c_par = atom_set.lattice_pars.r[2];
		
	var a_shift_perc = document.getElementById("opt_a_shift").value;
	var b_shift_perc = document.getElementById("opt_b_shift").value;
	var c_shift_perc = document.getElementById("opt_c_shift").value;
	
	var a_shift = vec_scale(a_par, a_shift_perc/100.0);
	var b_shift = vec_scale(b_par, b_shift_perc/100.0);
	var c_shift = vec_scale(c_par, c_shift_perc/100.0);
	
	//Second: apply shifts and periodic boundary conditions
		
	for (var s = 0; s < atom_set.atoms.length; ++s)
	{
		for (var a = 0; a < atom_set.atoms[s].length; ++a)
		{
			var final_pos = [atom_set.atoms[s][a].x, atom_set.atoms[s][a].y, atom_set.atoms[s][a].z];
			
			final_pos[0] += a_shift[0] + b_shift[0] + c_shift[0];
			final_pos[1] += a_shift[1] + b_shift[1] + c_shift[1];
			final_pos[2] += a_shift[2] + b_shift[2] + c_shift[2];
						
			final_pos = periodic_bound(final_pos, a_par, b_par, c_par);
			
			atom_set.atoms[s][a].x = final_pos[0];
			atom_set.atoms[s][a].y = final_pos[1];			
			atom_set.atoms[s][a].z = final_pos[2];
		}
		
	}
	
	//Third: generate and submit a .cell file
	
	var cell_file = "# CELL automatically generated by JMol NMR WebPage\n";

	if (atom_set.lattice_pars.r != null)
	{
		cell_file += "%BLOCK lattice_cart\n";
		cell_file += "ang\n";
	
		for (var i = 0; i < 3; ++i)
		{
			for (var j = 0; j < 3; ++j)
			{
				cell_file += atom_set.lattice_pars.r[i][j] + "\t";
			}
			cell_file += "\n";
		}
		cell_file += "%ENDBLOCK lattice_cart\n\n";
	}
	
	cell_file += "%BLOCK positions_abs\n";

	for(var s = 0; s < atom_set.speciesno; ++s)
	{
		for (var a = 0; a < atom_set.atoms[s].length; ++a)
		{
			cell_file += atom_set.atoms[s][a].to_string() + "\n";
		}
	}

	cell_file += "%ENDBLOCK positions_abs";
		
	var load_script = "load data \"model current_model\" " + cell_file + " end \"model current_model\"";

	var x_lat = parseInt(document.getElementById("x_lat").value);
	var y_lat = parseInt(document.getElementById("y_lat").value);
	var z_lat = parseInt(document.getElementById("z_lat").value);
	
	//Check that there are no errors
	if (x_lat <= 0)
	{
		x_lat = 1;
		document.getElementById("x_lat").value = 1;
	}

	if (y_lat <= 0)
	{
		y_lat = 1;
		document.getElementById("y_lat").value = 1;
	}

	if (z_lat <= 0)
	{
		z_lat = 1;
		document.getElementById("z_lat").value = 1;
	}
	
	if (x_lat > 1 || y_lat > 1 || z_lat > 1)
		load_script += "{" + x_lat + " " + y_lat + " " + z_lat + "}";
	
	//Fourth: reset the plots, reload the molecule, replot.
	//The resetting step is necessary because reloading the molecule will clear the labels of the various ellipsoids/echoes used to plot. Without it there will be weird behaviours.
	
	disable_NMR_controls();
	plot_update();
	Jmol.script(mainJmol, load_script);
	enable_NMR_controls();	
	dropdown_update();
	plot_update();
	
	//Reset the shift values to zero
	document.getElementById("opt_a_shift").value = "0";
	document.getElementById("opt_b_shift").value = "0";
	document.getElementById("opt_c_shift").value = "0";
	
}

function opt_transl_handler(evt)
{
	//Compatibility code - see console.js for details
	var evt = window.event || evt;
	var myKey = (evt.keyCode)? evt.keyCode: evt.charCode;
	var transl_text = document.getElementById("opt_transl");
	
	if (myKey == 13)
	{
		evt.preventDefault();
	}
	
	if (transl_text.value > 1.0)
	{
		transl_text.value = 1.0;
	}
	else if (transl_text.value < 0.0)
	{
		transl_text.value = 0.0;
	}
	plot_update();

}

function opt_width_handler(evt)
{
	//Compatibility code - see console.js for details
	var evt = window.event || evt;
	var myKey = (evt.keyCode)? evt.keyCode: evt.charCode;
	var transl_text = document.getElementById("opt_width");
	
	if (myKey == 13)
	{
		evt.preventDefault();
	}
	
	if (transl_text.value < 0.0)
	{
		transl_text.value = 0.0;
	}
	
	plot_update();
}

function label_composer()
{
	var label_row = "{all}.label = \"\";font label 12 sans bold; color label white;";

	if (label_components[0] == "" && label_components[1] == "" && label_components[2] == "")
		label_row += "labels off;"
	else
	{
		label_row += "labels " + label_components[0] + (label_components[1] == ""? "":"|");
		label_row += "<color [xC06000]>" + label_components[1] + "</color>" + (label_components[2] == ""? "":"|");
		label_row += "<color [x0060C0]>" + label_components[2] + "</color>;";
	}

	return label_row;
}

function q_units_choice_handler()
{
	document.getElementById("q_units").innerHTML = document.getElementById("q_units_choice").value;
	
	if (document.getElementById("efg_check_2").checked == true)
		efg_label_handler();
}
